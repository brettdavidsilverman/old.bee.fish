<!DOCTYPE html>
<html lang="en">
   <head>
      <script src="/head.js"></script>
      <meta charset="utf-8"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <link rel="stylesheet" type="text/css" href="/style.css" />
      <title>Javascript parser</title>
      <script src="/power-encoding/bit-string/bit-string.js"></script>
      <script src="/power-encoding/stream/stream.js"></script>
      <script src="/power-encoding/number/uint8/uint8.js"></script>
      <script src="/power-encoding/number/uint16/uint16.js"></script>
      <script src="/power-encoding/number/uint/uint.js"></script>
      <script src="/power-encoding/number/number.js"></script>
      <script src="/power-encoding/string/string.js"></script>
      <script src="/short-hand/short-hand.js"></script>
      <script src="/id/id.js"></script>
      <script src="/pointer/pointer.js"></script>
      <script src="/object/object.js"></script>
      <script src="/memory/memory.js"></script>
      <script src="/function/function.js"></script>
      <script src="/array/array.js"></script>
      <script src="/typed-array/typed-array.js"></script>
      <script src="/image/image.js"></script>
      <script src="/console/console.js"></script>
      <style>
pre {
   color: red;
}

.highlight {
   color: blue;
}
      </style>
   </head>
   <body>
      <script src="/body.js"></script>
      <h1>Javascript Parser</h1>

      <h2>Match</h2>
      
      <details>
      
         <summary>
A generic class for matching 
characters from an input stream.
         </summary>
      
         <pre>
            <script class="export">
const endOfFile = {};

class Match {
   #success = undefined;
   
   match(character) {
      throw new Error("Not implemented");
   }
   
   read(string) {
     
      var matched;
      
      for (var i = 0;
           i < string.length;
           ++i)
      {
         var character = string[i];
         
         var matched =
            this.match(character);
         
         if (matched)
            document.write("{" + escape(character) + "}");
            
         if (this.success || this.failed)
            return matched;
     
      }
      
      matched = this.match(endOfFile);
      
      return matched;
      
   }
   
   get success() {
      return this.#success;
   }
   
   set success(value) {
      if (value != this.#success)
      {
         this.#success = value;
         if (this.#success)
            this.onsuccess();
      }
   }
   
   onsuccess() {
   }
   
}


            </script>
         </pre>
      </details>
      
      <h2>Character</h2>
      
      <details>
         <summary>
A class to match an individual character.
         </summary>
         <pre>
            <script class="export">
class Character extends Match {
   #character;
   
   constructor(character) {
      super();
      this.#character = character;
   }
   
   match(character) {
      var matched =
         this.#character === character;
         
      if (matched) {
         this.success = true;
         this.value = character;
      }
      else
         this.failed = true;
         
      return matched;
   }
}
            </script>
         </pre>
      </details>
      
      <h2>Range</h2>
      
      <details>
         <summary>
A class to match a character
between a minimum and maximum.
         </summary>
         
         <pre>
            <script class="export">
class Range extends Match {
   #minimum;
   #maximum;
   constructor(minimum, maximum) {
      super();
      this.#minimum = minimum;
      this.#maximum = maximum;
   }
   
   match(character) {
   
      var matched =
         (this.#minimum <= character) &&
         (this.#maximum >= character);
         
      if (matched) {
         this.value = character;
         this.success = true;
      }
      else
         this.failed = true;
      
      return matched;
   }
}
            </script>
         </pre>
         
      </details>
      
      <h2>Word</h2>
     
      <details>
      
         <summary>
A class to match a string of 
characters.
         </summary>
         
         <pre>
            <script class="export">
class Word extends Match {
   #index = 0;
   #word;
   value = "";
   constructor(word) {
      super(word);
      this.#word = word;
   }
   
   match(character) {
      var matched =
         this.#word[this.#index] ===
         character;
         
      if (matched)
      {
         this.value += character;
         ++this.#index;
         if (this.#index === this.#word.length)
            this.success = true;
      }
      else
         this.failed = true;
         
      return matched;
   }
   
   
}

            </script>
         </pre>
      </details>
      
      <h2 id="or">Or</h2>
      
      <details>
         <summary>
A class to match a single item from an
array of input items.
         </summary>
         
         <pre>
            <script class="export">
class Or extends Match {
   #array;
   constructor(...array) {
      super();
      this.#array = array;
   }
   
   match(character) {
      var matched = false;
 
      for (var i = 0;
           i < this.#array.length;
           i++)
      {
         var item = this.#array[i];
         if (!item.failed) {
            if (item.match(character)) {
               matched = true;
               if (item.success) {
                  this.value = item.value;
                  this.index = i;
                  this.success = true;
                  return true;
               }
            }
         }
      }
      
      if (!matched)
         this.failed = true;
         
      return matched;
   }
}
            </script>
         </pre>
  
         <h3>Testing Or</h3>
      
         <details>
            <summary>
Create an alphabet class with a range of
upper and lower case chatacters.
            </summary>
            <pre>
               <script>

class Alphabet extends Or {
   constructor() {
      super(
         new Range("A", "Z"),
         new Range("a", "z")
      );
   }
   
}

var alphabet = new Alphabet();
alphabet.read("A");
if (alphabet.success)
   document.writeln(alphabet.value);
else
   document.writeln("No match");
   
               </script>
            </pre>
         </details>
      </details>
      
      <h2>And</h2>
      
      <details>
      
         <summary>
A class to match all input items in
order.
         </summary>
      
         <pre>
            <script class="export">
class And extends Match {
   #index = 0;
   #array;
   #value = [];
   constructor(...array) {
      super();
      this.#array = array;
      if (this.#array.length === 0) {
         this.failed = true;
      }
   }
   
   match(character) {
   
      var item;
      var matched;
      
      do {
         item = this.#array[this.#index];
         matched = item.match(character);
    
         if (item.success) {
            this.#value.push(item.value);
            if (++this.#index ===
                this.#array.length) {
               this.value = this.#value;
               this.success = true;
               return matched;
            }
         }
         else if (item.failed) {
            this.failed = true;
         }
         
      } while(item.success && !matched);
      
      if (!matched) {
         this.failed = true;
      }
      
      return matched;
   }
   
   get items() {
      return this.#array;
   }
}
            </script>
         </pre>

     
         <h3>Testing And</h3>
      
         <details>
            <summary>
Create an instance of And with [a,b,c]
characters to match.
            </summary>
            <pre>
               <script>
var and = new And(
   new Character("a"),
   new Character("b"),
   new Character("c")
);

and.read("abc");
if (and.success) {
   document.writeln(and.value.join(""));
}
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h2>Optional</h2>
      
      <details>
      
         <summary>
A class to optionally match an item.
         </summary>
      
         <pre>
            <script class="export">
class Optional extends Match {
   #optional;
   constructor(optional) {
      super();
      this.#optional = optional;
      this.success = true;
   }
   
   match(character) {
      var matched =
         this.#optional.match(character);
      
      if (this.#optional.success) {
         this.value =
            this.#optional.value;
      }
         
      return matched;
   }
}
            </script>
         </pre>
      
         
         <h3>Testing Optional</h3>
      
         <details>
            <summary>
Extend [a,b,c] with optional hyphens.
            </summary>
            <pre>
               <script>
class TestOptional extends And {
   constructor() {
      super(
         new Character("a"),
         new Optional(
            new Character("-")
         ),
         new Character("b"),
         new Optional(
            new Character("-")
         ),
         new Character("c"),
         new Optional(
            new Character(".")
         )
      );
   }
}
var test;
test = new TestOptional();
test.read("abc");
if (test.success) {
   document.writeln(test.value.join(""));
}
else
   document.writeln("No match");

test = new TestOptional();
test.read("a-b-c");
if (test.success) {
   document.writeln(test.value.join(""));
}
else
   document.writeln("No match");
               </script>
            </pre>
         
         </details>
         
      </details>
      
      <h2>Not</h2>
      
      <details>
      
         <summary>
A class to match a single character 
that doesnt match the input item.
         </summary>
      
         <pre>
            <script class="export">
class Not extends Match {
   #match;
   constructor(match) {
      super();
      this.#match = match;
      this.value = "";
   }
   
   match(character) {

      var matched =
         this.#match.match(character);
      
      if (!matched) {
         this.value += character;
         this.success = true;
      }
      else if (this.#match.success) {
         this.failed = true;
      }
      
      return !matched;
      
   }
   
}
            </script>
         </pre>
      
         
         <h3>Testing Not</h3>
         
         <details>
            <summary>
Create a class that matches every
character except "A".
            </summary>
            <pre>
               <script>
class NotA extends Not {
   constructor() {
      super(
         new Character("A")
      );
   }
}

var notA = new NotA();
notA.read("b");
if (notA.success)
   document.writeln(notA.value)
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h2>Repeat</h2>
      
      <details>
         <summary>
A class to match an array of items
matching the input Match constructor.

When the input Match constructor fails,
the repeat finishes.
         </summary>
      
         <pre>
            <script class="export">
class Repeat extends Match {
   #Match;
   #match;
   #values = [];
   value = undefined;
  
   constructor(Match, Join) {
      super();
      this.#Match = Match;
      this.#match = new this.#Match();
      
   }
   
   match(character) {
   
      var matched =
         this.#match.match(character);
         
      if (this.#match.success) {
 
            this.#values.push(
               this.#match.value
            );
            
         this.#match =
            new this.#Match();
           
      }
      
      
      
      if (!matched ||
          character === endOfFile) {
            
        this.value = this.#values;
        this.success = true;

      }
      
      return matched;
      
   }
   
}


            </script>
         </pre>
      
         <h3>Simple test</h3>
         <details>
            <summary>
Create a repeater class that matches the
Not A class.
            </summary>
            <pre>
               <script>
class RepeatNotA extends Repeat {
   constructor() {
      super(NotA)
   }
      
}

var repeatNotA = new RepeatNotA();
repeatNotA.read("aaaBA");
if (repeatNotA.success)
   document.writeln(repeatNotA.value);
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
         
         <h3>Testing Repeat with Sentence</h3>
         
         <details>
            <summary>
Create a series of classes to parse a
sentence consisting of tokens seperated
by punctuation.
            </summary>
            <pre>
               <script>

class Punctuation extends Or {
   constructor() {
      super(
         new Character(" "),
         new Character("\t"),
         new Character(".")
      );
   }
}

class Char extends Not {
   constructor() {
      super(
         new Punctuation()
      );
   }
}

class Token extends Repeat {
   constructor() {
      super(
         Char
      );
   }
   
}

class Seperator extends Repeat {

   constructor() {
      super(
         Punctuation
      );
   }
   
}

class TokenJoiner extends And {
   constructor() {
      super(
         new Token(),
         new Optional(
            new Seperator()
         )
      );
   }
}
   
class Sentence extends Repeat {
   constructor() {
      super(
         TokenJoiner
      );
   }
   
}

var sentence = new Sentence();

sentence.read("hello    to the world.");

if (sentence.success)
   sentence.value.forEach(
      chars =>
         document.write("\r\n*" + chars[0].join("") + "*")
   );
else
   document.writeln("No match");

               </script>
            </pre>
         </details>
      </details>
      
      
      <h2>Capture</h2>
      
      <details>
         <summary>
Matches all the properties in order.
Allows for sub objects, or nested.

The captured input is the value
property.
         </summary>
      
         <pre>
            <script class="export">
class Capture extends Match {

   #object;
   #keys;
   #and;
   
   constructor(object) {
      super();
      this.#object = object;
      this.#keys = Object.keys(object);
      this.#and = new And(
         ...Object.values(this.#object)
      );
   }
   
   match(character) {
      var matched =
         this.#and.match(character);
        
      if (this.#and.success) {
         var i = 0;
         var value = this;
         this.#and.value.forEach(
            (item) => {
               var key = this.#keys[i++];
               value[key] = item;
            }
         );
         this.value = value;
         this.success = true;
      }
      else if (!matched) {
         this.failed = true;
      }
      
      return matched;

   }
   
}
            </script>
         </pre>
      
         <h3>Testing Capture</h3>
      
         <details>
            <summary>
Capture a simple object with a sub object.
            </summary>
            <pre>
               <script>
var capture = new Capture(
   {
      a: new Character("a"),
      b: new Character("b"),
      c: new Capture(
         {
            word: new Word("nested")
         }
      )
   }
);

capture.read("abnested");
document.writeln(capture);
document.writeln(capture.value);
document.writeln(capture.value.c);
               </script>
            </pre>
         </details>
      </details>
      
      <h2 class="highlight">HTTP Request</h2>
      <details>
         
         <summary>
All the classes require to match a
simple HTTP request
         </summary>
      
         <h3>Whitespace</h3>
       
         <details>
         
            <summary>
A class to match a repeating space or
tab character.
            </summary>
      
         <pre>
            <script class="export">
class WhitespaceCharacter extends Or {
   constructor() {
      super(
         new Character(" "),
         new Character("\t")
      );
   }
}

class Whitespace extends Repeat {

   constructor() {
      super(WhitespaceCharacter);
   }
   
   
}
            </script>
         </pre>

         <h4>Whitespace test</h4>
         <details>
            <summary>
Test consecutive repeat of white space.
            </summary>
            <pre>
               <script>
var ws = new Whitespace();
ws.read("\t  abc");
if (ws.success)
   document.writeln("*" + ws.value.join("") + "*");
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h3>Colon</h3>
      
      <details>
         <summary>
Create a Colon class wrapped with optional
whitespace.

This class is used the http request first
line and headers.
         </summary>
         <pre>
            <script class="export">
class Colon extends And {
   constructor() {
       super(
          new Optional(new Whitespace()),
          new Character(":"),
          new Optional(new Whitespace())
       );
   }
   
}
            </script>
         </pre>
     
      
         <h4>Testing Colon</h4>
         <details>
            <summary>
Test the Colon class.
            </summary>
            <pre>
               <script>
var colon = new Colon();
colon.read(":");
document.writeln(colon.success);

               </script>
            </pre>
         </details>
      </details>
      
      <h3>NewLine</h3>
      
      <details>
      
         <summary>
Matches the carriage return and line
feed characters.
         </summary>
         
         <pre>
            <script class="export">
class NewLine extends Match {
   static standard = "\r\n";
   #firstChar = null;
   
   match(character) {
      if (this.#firstChar === null)
      {
         if (character === "\r" ||
             character === "\n")
         {
            this.#firstChar = character;
            return true;
         }
      }
      else if (this.#firstChar === "\r")
      {
         if (character === "\n" ||
             character === endOfFile)
         {
            this.success = true;
            return true;
         }
      }
      else if (this.#firstChar === "\n")
      {
         this.success = true;
         return false;
      }
      else
      {
         this.failed = true;
         return false;
      }
   }
   
   onsuccess() {
      super.onsuccess();
      this.value = NewLine.standard;
   }
}
             </script>
         </pre>
       
         <h4>Testing New Line</h4>
       
         <details>
            <summary>
Test new line with different variations.
            </summary>
            <pre>
               <script>
var newLine1 = new NewLine();
newLine1.read("\r\n");
document.writeln(newLine1.success);

var newLine2 = new NewLine();
newLine2.read("\r");
document.writeln(newLine2.success);

var newLine3 = new NewLine();
newLine3.read("\n");
document.writeln(newLine3.success);

               </script>
            </pre>
         </details>
      </details>
       
      <h3>Identifier</h3>
       
      <details>
         <summary>
Define a valid javascript identifier.
This is used instead of the standard http
verb in the requests first line.
         </summary>
         <pre>
            <script class="export">
class FirstIdentifierCharacter
   extends Or
{
   constructor() {
      super(
         new Range("a", "z"),
         new Range("A", "Z"),
         new Character("_")
      )
   }
}

class SubsequentIdentifierCharacter
   extends Or
{
   constructor() {
      super(
         new Range("0", "9"),
         new Range("a", "z"),
         new Range("A", "Z"),
         new Character("_")
      )
   }
}

class Identifier extends And
{
   #value = "";
   constructor() {
      super(
         new FirstIdentifierCharacter(),
         new Repeat(
            SubsequentIdentifierCharacter
         )
      )
   }
   
   match(character) {
      var matched =
         super.match(character);
      if (matched)
         this.#value += character;
      if (this.success)
         this.value = this.#value;
      return matched;
   }
   
}
             </script>
         </pre>
   
       
         <h4>Testing Identifier</h4>
       
         <details>
            <summary>
Test the identifier class correctly
matched a sample.
            </summary>
            <pre>
               <script>
var identifier = new Identifier();
identifier.read("a_bc1 ");
if (identifier.success)
   document.writeln(identifier.value + "*");
else
   document.writeln("No match");
   
              </script>
           </pre>
        </details>
     </details>
     
     <h3>Path</h3>
     <details>
        <summary>
For now, Path is a simple match of
characters. Later, Path will be extended
to count up and down via Power Encoding.
        </summary>
        <pre>
           <script class="export">
class PathCharacter extends Or {
   constructor() {
      super(
         new Character("/"),
         new Character("."),
         new Character("-"),
         new Character("_"),
         new Range("a", "z"),
         new Range("A", "Z")
      )
   }
}

class Path extends Repeat {
   constructor() {
      super(
         PathCharacter
      )
   }
   
   onsuccess() {
      this.value = this.value.join("");
   }

}
            </script>
         </pre>
        
         <h4>Testing Path</h4>
         <details>
            <summary>
Test with this path.
            </summary>
            <pre>
               <script>
var path = new Path();
path.read("/parser/index.html");
document.writeln(path);
if (path.success) {
   document.writeln(path.value);
}
               </script>
            </pre>
         </details>
      </details>
    
      <h3>Request first line</h3>
      <details>
         <summary>
Put the verb, path and version together
in a Capture class for the HTTP request
first line.
         </summary>
         <pre>
            <script class="export">
class FirstLine extends Capture {

   constructor() {
      super( {
         verb: new Identifier(),
         whitespace1: new Whitespace(),
         path: new Path(),
         whitespace2: new Whitespace(),
         version:
            new Word("HTTP/1.1"),
         newLine:
            new NewLine()
     } );
   }
}
            </script>
         </pre>
            
         <h4>Test First Line</h4>
         <details>
            <summary>
Check the FirstLine class.
            </summary>
            <pre>
               <script>
var firstLine = new FirstLine();
firstLine.read(
   "GET /parser/index.html HTTP/1.1\r\n"
);

if (firstLine.success)
   document.writeln(firstLine.value);
else
   document.writeln("No match" + firstLine);
               </script>
            </pre>
         </details>
      </details>
         
      <h3>Header Name and Value</h3>
      <details>
         <summary>
Define the header name and value as a 
repeat if any character except colon (:)
or new line.

         </summary>
         <pre>
            <script class="export">
class HeaderCharacter extends Not {
   constructor() {
      super(
         new Or(
            new NewLine(),
            new Character(":")
         )
      );
   }
}

class HeaderName extends Repeat {
   constructor() {
      super(
         HeaderCharacter
      );
   }
}

class HeaderValue extends Repeat {
   constructor() {
      super(
         HeaderCharacter
      );
   }
}
            </script>
         </pre>
         
         <h4>Testing Header Value</h4>
         <details>
            <summary>
Do a test of the HeaderValue class.
            </summary>
            <pre>
               <script>
var headerValue = new HeaderValue();
headerValue.read("abc-%20 a\r\n");

if (headerValue.success) {
   document.writeln(headerValue.value.join(""));
}
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h3>Header Lines</h3>
      <details>
         <summary>
Put the HeaderNanme, Colon, HeaderValue
and NewLine together in a capture class
for a HTTP requests headers.
         </summary>
         <pre>
            <script class="export">
class HeaderLine extends Capture {
   constructor() {
      super(
         {
            name: new HeaderName(),
            colon: new Colon(),
            _value: new HeaderValue(),
            newLine: new NewLine()
         }
      );
   }
   
   write() {
      document.write(
         this.name.join("")
      );
      document.write(":\t");
      document.writeln(
         this._value.join("")
      );
   }
}

class Headers extends Repeat {
   constructor() {
      super(HeaderLine)
   }
}

            </script>
         </pre>
         
         <h4>Testing Header Line</h4>
         <details>
            <summary>
Test the HeaderLine class with a hello
world example.
            </summary>
            <pre>
               <script>
var headerLine = new HeaderLine();
headerLine.read("hello: world\r\n");

if (headerLine.success) {
   headerLine.write();
}
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h3>Complete Request</h3>
      <details>
         <summary>
Create the Request class that captures
the HTTP request first line and
subsequent headers.
         </summary>
         <pre>
            <script class="export">
class Request extends Capture {
   constructor() {
      super(
         {
            firstLine: new FirstLine(),
            headers: new Headers()
         }
      );
   }
}
            </script>
         </pre>
       
         <h4>Testing Request</h4>
         
         <details>
            <summary>
Test with sample input from the linux
curl program.
            </summary>
            <pre>
               <script>
var input = [
   "GET /parser/index.html HTTP/1.1",
   "Host: bee.fish",
   "User-Agent: curl/7.64.0",
   "Accept: */*",
   ""
].join("\r\n");

var request = new Request();

request.read(input);

if (request.success) {

   document.writeln(
      request.firstLine.verb + " " + 
      request.firstLine.path
   );
   
   request.headers.forEach(
      (headerLine) =>
         headerLine.write()
   );
   
}

               </script>
            </pre>
         </details>
      </details>
   </details>
      <a onclick="generateCode()"><h2 class="highlight">Code</h2></a>
      <pre>
         <script>
if (document.location.search === "?code")
   generateCode();

function generateCode() {
   var x = document.querySelectorAll("script.export");

   var doc = document.open();
   doc.write("<html><body><pre>");
   x.forEach(
      (script) =>
         doc.write(script.innerText)
   );
   doc.write("</pre></body></html>");
   doc.close();
}
         </script>
      </pre>
   </body>
</html>
