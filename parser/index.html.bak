<!DOCTYPE html>
<html lang="en">
   <head>
      <script src="/head.js"></script>
      <meta charset="utf-8"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <link rel="stylesheet" type="text/css" href="/style.css" />
      <title>Javascript parser</title>
      <script src="/power-encoding/bit-string/bit-string.js"></script>
      <script src="/power-encoding/stream/stream.js"></script>
      <script src="/power-encoding/number/uint8/uint8.js"></script>
      <script src="/power-encoding/number/uint16/uint16.js"></script>
      <script src="/power-encoding/number/uint/uint.js"></script>
      <script src="/power-encoding/number/number.js"></script>
      <script src="/power-encoding/string/string.js"></script>
      <script src="/short-hand/short-hand.js"></script>
      <script src="/id/id.js"></script>
      <script src="/pointer/pointer.js"></script>
      <script src="/object/object.js"></script>
      <script src="/memory/memory.js"></script>
      <script src="/function/function.js"></script>
      <script src="/array/array.js"></script>
      <script src="/typed-array/typed-array.js"></script>
      <script src="/image/image.js"></script>
      <script src="/console/console.js"></script>
      <style>
pre {
   color: red;
}
      </style>
   </head>
   <body>
      <script src="/body.js"></script>
      <h1>Javascript Parser</h1>

      <h2>Match</h2>
      
      <details open>
      
         <summary>
A generic class for matching 
characters from an input stream.
         </summary>
      
         <pre>
            <script class="export">
const endOfFile = {};

class Match {
   #success = undefined;
   
   match(character) {
      throw new Error("Not implemented");
   }
   
   read(string) {
     
      var matched;
      
      for (var i = 0;
           i < string.length;
           ++i)
      {
         var character = string[i];
         
         var matched =
            this.match(character);
      
         if (matched) {
            document.write("{" + character + "}");
         }
         
         if (this.success || this.failed)
            return matched;
     
      }
      
      // Send the end of file character
      matched = this.match(endOfFile);
      
      return matched;
      
   }
   
   get success() {
      return this.#success;
   }
   
   set success(value) {
      if (value != this.#success)
      {
         this.#success = value;
         if (this.#success)
            this.onsuccess();
      }
   }
   
   onsuccess() {
     // document.write(this.constructor.name);
   }
}


            </script>
         </pre>
      </details>
      
      <h2>Character</h2>
      
      <details open>
         <summary>
A class to match an individual character.
         </summary>
         <pre>
            <script class="export">
class Character extends Match {
   #character;
   
   constructor(character) {
      super();
      this.#character = character;
   }
   
   match(character) {
      var matched =
         this.#character === character;
         
      if (matched) {
         this.success = true;
         this.value = character;
      }
      else
         this.failed = true;
         
      return matched;
   }
}
            </script>
         </pre>
      </details>
      
      <h2>Range</h2>
      
      <details open>
         <summary>
A class to match a character
between a minimum and maximum.
         </summary>
         
         <pre>
            <script class="export">
class Range extends Match {
   #minimum;
   #maximum;
   constructor(minimum, maximum) {
      super();
      this.#minimum = minimum;
      this.#maximum = maximum;
   }
   
   match(character) {
   
      var matched =
         (this.#minimum <= character) &&
         (this.#maximum >= character);
         
      if (matched) {
         this.value = character;
         this.success = true;
      }
      else
         this.failed = true;
      
      return matched;
   }
}
            </script>
         </pre>
         
      </details>
      
      <h2>Word</h2>
     
      <details open>
      
         <summary>
A class to match a string of 
characters.
         </summary>
         
         <pre>
            <script class="export">
class Word extends Match {
   #index = 0;
   #word;
   value = "";
   constructor(word) {
      super(word);
      this.#word = word;
   }
   
   match(character) {
      var matched =
         this.#word[this.#index] ===
         character;
         
      if (matched)
      {
         this.value += character;
         ++this.#index;
         if (this.#index === this.#word.length)
            this.success = true;
      }
      else
         this.failed = true;
         
      return matched;
   }
   
   
}

            </script>
         </pre>
      </details>
      
      <h2 id="or">Or</h2>
      
      <details open>
         <summary>
A class to match a single item from an
array of input items.
         </summary>
         
         <pre>
            <script class="export">
class Or extends Match {
   #array;
   constructor(...array) {
      super();
      this.#array = array;
   }
   
   match(character) {
      var matched = false;
 
      for (var i = 0;
           i < this.#array.length;
           i++)
      {
         var item = this.#array[i];
         if (!item.failed) {
            if (item.match(character)) {
               matched = true;
               if (item.success) {
                  this.value = item.value;
                  this.index = i;
                  this.success = true;
                  return true;
               }
            }
         }
      }
      
      if (!matched)
         this.failed = true;
         
      return matched;
   }
}
            </script>
         </pre>
  
         <h3>Testing Or</h3>
      
         <details open>

            <pre>
               <script>

class Alphabet extends Or {
   constructor() {
      super(
         new Range("A", "Z"),
         new Range("a", "z")
      );
   }
   
}

var alphabet = new Alphabet();
alphabet.read("A");
if (alphabet.success)
   document.writeln(alphabet.value);
else
   document.writeln("No match");
   
               </script>
            </pre>
         </details>
      </details>
      
      <h2>And</h2>
      
      <details open>
      
         <summary>
A class to match all input items in
order.
         </summary>
      
         <pre>
            <script class="export">
class And extends Match {
   #index = 0;
   #array;
   #value = [];
   constructor(...array) {
      super();
      this.#array = array;
      if (this.#array.length === 0) {
         this.failed = true;
      }
   }
   
   match(character) {
   
      var item;
      var matched;
      
      do {
         item = this.#array[this.#index];
         matched = item.match(character);
    
         if (item.success) {
            this.#value.push(item.value);
            if (++this.#index ===
                this.#array.length) {
               this.value = this.#value;
               this.success = true;
               return matched;
            }
         }
         else if (item.failed) {
            this.failed = true;
         }
         
      } while(item.success && !matched);
      
      if (!matched) {
         this.failed = true;
      }
      
      return matched;
   }
   
   get items() {
      return this.#array;
   }
}
            </script>
         </pre>

     
         <h3>Testing And</h3>
      
         <details open>
            <pre>
               <script>
var and = new And(
   new Character("a"),
   new Character("b"),
   new Character("c")
);

and.read("abc");
if (and.success) {
   document.writeln(and.value.join(""));
}
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h2>Optional</h2>
      
      <details open>
      
         <summary>
A class to optionally match an item.
         </summary>
      
         <pre>
            <script class="export">
class Optional extends Match {
   #optional;
   constructor(optional) {
      super();
      this.#optional = optional;
      this.success = true;
   }
   
   match(character) {
      var matched =
         this.#optional.match(character);
      
      if (this.#optional.success) {
         this.value =
            this.#optional.value;
      }
         
      return matched;
   }
}
            </script>
         </pre>
      
         
         <h3>Testing Optional</h3>
      
         <details open>
            <pre>
               <script>
class TestOptional extends And {
   constructor() {
      super(
         new Character("a"),
         new Optional(
            new Character("-")
         ),
         new Character("b"),
         new Optional(
            new Character("-")
         ),
         new Character("c"),
         new Optional(
            new Character(".")
         )
      );
   }
}
var test;
test = new TestOptional();
test.read("abc");
if (test.success) {
   document.writeln(test.value.join(""));
}
else
   document.writeln("No match");

test = new TestOptional();
test.read("a-b-c");
if (test.success) {
   document.writeln(test.value.join(""));
}
else
   document.writeln("No match");
               </script>
            </pre>
         
         </details>
         
      </details>
      
      <h2>Not</h2>
      
      <details open>
      
         <summary>
A class to match a single character 
that doesnt match the input item.
         </summary>
      
         <pre>
            <script class="export">
class Not extends Match {
   #match;
   constructor(match) {
      super();
      this.#match = match;
      this.value = "";
   }
   
   match(character) {

      var matched =
         this.#match.match(character);
      
      if (!matched) {
         this.value += character;
         this.success = true;
      }
      else if (this.#match.success) {
         this.failed = true;
      }
      
      return !matched;
      
   }
   
}
            </script>
         </pre>
      
         
         <h3>Testing Not</h3>
         
         <details open>
            
            <pre>
               <script>
class NotA extends Not {
   constructor() {
      super(
         new Character("A")
      );
   }
}

var notA = new NotA();
notA.read("b");
if (notA.success)
   document.writeln(notA.value)
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h2>Repeat</h2>
      
      <details open>
         <summary>
A class to match an array of items
matching the input Match constructor.
<p/>
When the input Match constructor fails,
the repeat finishes.
         </summary>
      
         <pre>
            <script class="export">
class Repeat extends Match {
   #Match;
   #match;
   #values = [];
   value = undefined;
  
   constructor(Match, Join) {
      super();
      this.#Match = Match;
      this.#match = new this.#Match();
      
   }
   
   match(character) {
   
      var matched =
         this.#match.match(character);
         
      if (this.#match.success) {
 
            this.#values.push(
               this.#match.value
            );
            
         this.#match =
            new this.#Match();
           
      }
      
      
      
      if (!matched ||
          character === endOfFile) {
            
        this.value = this.#values;
        this.success = true;

      }
      
      return matched;
      
   }
   
}


            </script>
         </pre>
      
         <h3>Simple test</h3>
         <details open>
            <pre>
               <script>
class RepeatNotA extends Repeat {
   constructor() {
      super(NotA)
   }
      
}

var repeatNotA = new RepeatNotA();
repeatNotA.read("aaaBA");
if (repeatNotA.success)
   document.writeln(repeatNotA.value);
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
         
         <h3>Testing Repeat with Sentence</h3>
         
         <details open>
            <pre>
               <script>

class Punctuation extends Or {
   constructor() {
      super(
         new Character(" "),
         new Character("\t"),
         new Character(".")
      );
   }
}

class Char extends Not {
   constructor() {
      super(
         new Punctuation()
      );
   }
}

class Token extends Repeat {
   constructor() {
      super(
         Char
      );
   }
   
}

class Seperator extends Repeat {

   constructor() {
      super(
         Punctuation
      );
   }
   
}

class TokenJoiner extends And {
   constructor() {
      super(
         new Token(),
         new Optional(
            new Seperator()
         )
      );
   }
}
   
class Sentence extends Repeat {
   constructor() {
      super(
         TokenJoiner
      );
   }
   
}

var sentence = new Sentence();

sentence.read("hello    to the world.");

if (sentence.success)
   sentence.value.forEach(
      chars =>
         document.write("\r\n*" + chars[0].join("") + "*")
   );
else
   document.writeln("No match");

               </script>
            </pre>
         </details>
      </details>
      
      
      <h2>Capture</h2>
      
      <details open>
         <summary>
Matches all the properties in order.
Allows for sub objects, or nested.
<p/>
The captured input is the value
property.
         </summary>
      
         <pre>
            <script class="export">
class Capture extends Match {

   #object;
   #keys;
   #and;
   
   constructor(object) {
      super();
      this.#object = object;
      this.#keys = Object.keys(object);
      this.#and = new And(
         ...Object.values(this.#object)
      );
   }
   
   match(character) {
      var matched =
         this.#and.match(character);
        
      if (this.#and.success) {
         var i = 0;
         var value = {};
         this.#and.value.forEach(
            (item) => {
               var key = this.#keys[i++];
               value[key] = item;
            }
         );
         this.value = value;
         this.success = true;
      }
      else if (!matched) {
         this.failed = true;
      }
      
      return matched;

   }
   
}
            </script>
         </pre>
      
         <h3>Testing Capture</h3>
      
         <details open>
            <pre>
               <script>
var capture = new Capture(
   {
      a: new Character("a"),
      b: new Character("b"),
      c: new Capture(
         {
            word: new Word("nested")
         }
      )
   }
);

capture.read("abnested");
document.writeln(capture);
document.writeln(capture.value);
document.writeln(capture.value.c);
               </script>
            </pre>
         </details>
      </details>
      
      <h2>HTTP Request</h2>
      <details open>
         
         <summary>
All the classes require to match a
simple HTTP request
         </summary>
      
         <h3>Whitespace</h3>
       
         <details open>
         
            <summary>
A class to match a repeating space or
tab character.
            </summary>
      
         <pre>
            <script class="export">
class WhitespaceCharacter extends Or {
   constructor() {
      super(
         new Character(" "),
         new Character("\t")
      );
   }
}

class Whitespace extends Repeat {

   constructor() {
      super(WhitespaceCharacter);
   }
   
   
}
            </script>
         </pre>

         <h4>Whitespace test</h4>
         <details open>
            <pre>
               <script>
var ws = new Whitespace();
ws.read("\t  abc");
if (ws.success)
   document.writeln("*" + ws.value.join("") + "*");
else
   document.writeln("No match");
               </script>
            </pre>
         </details>
      </details>
      
      <h3>Colon</h3>
      
      <details open>
         <pre>
            <script>
class Colon extends And {
   constructor() {
       super(
          new Optional(new Whitespace()),
          new Character(":"),
          new Optional(new Whitespace())
       );
   }
   
}

var colon = new Colon();
colon.read(":");
document.writeln(colon);

            </script>
         </pre>
      </details>
      
      <h3>NewLine</h3>
      
      <details open>
      
         <summary>
Matches the carriage return and line
feed characters.
         </summary>
         
         <pre>
            <script>
class NewLine extends And {
   static standard = "\r\n";
   
   constructor() {
      super(
         new Optional(
            new Character("\r")
         ),
         new Character("\n")
      );
   }
   
   onsuccess() {
      super.onsuccess();
      this.value = "\r\n";
   }
}

var newLine = new NewLine();
newLine.read("\r\n");
if (newLine.success) {
   document.writeln(escape(newLine.value));
}
            </script>
         </pre>
       </details>
       
       <h3>Identifier</h3>
       
       <details open>
         <pre>
            <script>
class FirstIdentifierCharacter
   extends Or
{
   constructor() {
      super(
         new Range("a", "z"),
         new Range("A", "Z"),
         new Character("_")
      )
   }
}

class SubsequentIdentifierCharacter
   extends Or
{
   constructor() {
      super(
         new Range("0", "9"),
         new Range("a", "z"),
         new Range("A", "Z"),
         new Character("_")
      )
   }
}

class Identifier extends And
{
   #value = "";
   
   constructor() {
      super(
         new FirstIdentifierCharacter(),
         new Optional(
            new Repeat(
               SubsequentIdentifierCharacter
            )
         )
         
      )
   }
   
}

var identifier = new Identifier();
identifier.read("a_bc1 ");
if (identifier.success)
   document.writeln(identifier.value + "*");
else
   document.writeln("No match");
   
            </script>
         </pre>
      </details>
      
      <h3>Path</h3>
      <details open>
         <pre>
            <script>
class PathCharacter extends Or {
   constructor() {
      super(
         new Character("/"),
         new Character("."),
         new Character("-"),
         new Range("a", "z"),
         new Range("A", "Z")
      )
   }
}

class Path extends Repeat {
   constructor() {
      super(
         PathCharacter
      )
   }
   
   onsuccess() {
      this.value = this.value.join("");
   }

}

var path = new Path();
path.read("/parser/index.html");
document.writeln(path);
if (path.success) {
   document.writeln(path.value);
}
            </script>
         </pre>
      </details>
      
      <h3>Request first line</h3>
      <details open>
         <pre>
            <script>
class FirstLine extends Capture {

   constructor() {
      super( {
         verb: new Identifier(),
         whitespace1: new Whitespace(),
         path: new Path(),
         whitespace2: new Whitespace(),
         version:
            new Word("HTTP/1.1"),
         newLine:
            new NewLine()
     } );
   }
}

var firstLine = new FirstLine();
firstLine.read(
   "GET /parser/index.html HTTP/1.1\r\n"
);

if (firstLine.success)
   document.writeln(firstLine.value);
else
   document.writeln("No match" + firstLine);
            </script>
         </pre>
      </details>
      
      <h3>Header Value</h3>
      <details open>
         <pre>
            <script>
class HeaderValue extends Not {
   constructor() {
      super(
         new NewLine()
      )
   }
}

var headerValue = new HeaderValue();
headerValue.read("abc%20 a\r\n");

if (headerValue.success) {
   document.writeln(headerValue.value);
}
else
   document.writeln("No match");
            </script>
         </pre>
      </details>
      
      <h3>Request header</h3>
      <details open>
         <pre>
            <script>
class HeaderLine extends Capture {
   constructor() {
      super(
         {
            name: new Identifier(),
            colon: new Colon(),
            value: new HeaderValue(),
            newLine: new NewLine()
         }
      );
   }
}

var headerLine = new HeaderLine();
headerLine.read("hello: world\r\n");

if (headerLine.success) {
   document.writeln(headerLine.value);
}
else
   document.writeln("No match");
            </script>
         </pre>
      </details>
      
      <h3>Complete request</h3>
      <details open>
         <pre>
            <script>

var request = new Capture(
   {
      firstLine: new FirstLine(),
      headers: new Repeat(
         HeaderLine,
         NewLine
      )
      
   }
);

var input = [
   "GET / HTTP/1.1",
   "Host: bee.fish",
   "User-Agent: curl/7.64.0",
   "Accept: */*",
   ""
].join("\r\n");

request.read(input);
document.writeln(request);
if (request.success) {

   request.value.headers.forEach(
      (header) =>
         document.writeln(header)
   );
   
}

               </script>
            </pre>
         </details>
      </details>
      
   </body>
</html>
